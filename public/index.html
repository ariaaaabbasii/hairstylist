document.addEventListener('DOMContentLoaded', function() {
    // Chat Widget Elements
    const chatWidget = {
        elements: {
            widget: document.getElementById('chat-widget'),
            toggleBtn: document.getElementById('chat-widget-toggle'),
            container: document.getElementById('chat-widget-container'),
            closeBtn: document.getElementById('chat-widget-close'),
            messagesContainer: document.getElementById('chat-widget-messages'),
            input: document.getElementById('chat-widget-input'),
            sendBtn: document.getElementById('chat-widget-send')
        },
        
        state: {
            isOpen: false,
            isProcessing: false,
            threadId: null,
            messages: [],
            initialized: false
        },
        
        // Storage keys
        storage: {
            THREAD_ID: 'luminous_chat_thread_id',
            MESSAGES: 'luminous_chat_messages'
        },
        
        // Initialize the chat widget
        init: function() {
            // Load previous state if available
            this.loadState();
            
            // Set up event listeners
            this.setupEventListeners();
            
            // Initialize the chat if not already initialized
            if (!this.state.initialized) {
                this.initializeChat();
            } else {
                this.loadMessages();
            }
        },
        
        // Set up event listeners
        setupEventListeners: function() {
            // Toggle chat open/closed
            this.elements.toggleBtn.addEventListener('click', () => this.toggleChat());
            
            // Close chat
            this.elements.closeBtn.addEventListener('click', () => this.closeChat());
            
            // Send message on button click
            this.elements.sendBtn.addEventListener('click', () => this.sendMessage());
            
            // Send message on Enter key (but allow Shift+Enter for new lines)
            this.elements.input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
            
            // Handle input changes (enable/disable send button)
            this.elements.input.addEventListener('input', () => {
                // Auto-resize textarea
                this.elements.input.style.height = 'auto';
                this.elements.input.style.height = (this.elements.input.scrollHeight > 100 ? '100px' : this.elements.input.scrollHeight + 'px');
                
                // Enable/disable send button based on content
                this.elements.sendBtn.disabled = this.elements.input.value.trim() === '';
            });
        },
        
        // Toggle chat open/closed
        toggleChat: function() {
            if (this.state.isOpen) {
                this.closeChat();
            } else {
                this.openChat();
            }
        },
        
        // Open chat
        openChat: function() {
            this.elements.container.classList.add('open');
            this.state.isOpen = true;
            this.scrollToBottom();
            
            // Focus input field
            setTimeout(() => {
                this.elements.input.focus();
            }, 300);
        },
        
        // Close chat
        closeChat: function() {
            this.elements.container.classList.remove('open');
            this.state.isOpen = false;
        },
        
        // Initialize chat
        initializeChat: async function() {
            try {
                // Create a thread if we don't have one
                if (!this.state.threadId) {
                    const threadId = await this.createThread();
                    this.state.threadId = threadId;
                    this.saveState();
                }
                
                // Add welcome message
                const welcomeMessage = "Welkom bij Luminous! Ik ben je virtuele assistent. Hoe kan ik je vandaag helpen? Je kunt me vragen stellen over onze diensten, prijzen, openingstijden, of haar- en verzorgingstips.";
                this.addMessageToUI(welcomeMessage, false);
                this.state.messages.push({
                    content: welcomeMessage,
                    isUser: false,
                    timestamp: new Date().toISOString()
                });
                this.saveState();
                
                this.state.initialized = true;
                this.saveState();
            } catch (error) {
                console.error('Error initializing chat:', error);
                this.addMessageToUI("Sorry, er is een probleem opgetreden bij het initialiseren van de chat. Vernieuw de pagina en probeer het opnieuw.", false);
            }
        },
        
        // Load saved state from localStorage
        loadState: function() {
            try {
                const threadId = localStorage.getItem(this.storage.THREAD_ID);
                const messagesJson = localStorage.getItem(this.storage.MESSAGES);
                
                if (threadId) {
                    this.state.threadId = threadId;
                    this.state.initialized = true;
                }
                
                if (messagesJson) {
                    this.state.messages = JSON.parse(messagesJson);
                }
            } catch (error) {
                console.error('Error loading chat state:', error);
                // Reset state if there's an error
                this.state.threadId = null;
                this.state.messages = [];
                this.state.initialized = false;
                localStorage.removeItem(this.storage.THREAD_ID);
                localStorage.removeItem(this.storage.MESSAGES);
            }
        },
        
        // Save state to localStorage
        saveState: function() {
            try {
                localStorage.setItem(this.storage.THREAD_ID, this.state.threadId);
                localStorage.setItem(this.storage.MESSAGES, JSON.stringify(this.state.messages));
            } catch (error) {
                console.error('Error saving chat state:', error);
            }
        },
        
        // Load messages into UI
        loadMessages: function() {
            // Clear messages container
            this.elements.messagesContainer.innerHTML = '';
            
            // Add each message to UI
            this.state.messages.forEach(message => {
                this.addMessageToUI(message.content, message.isUser, false);
            });
            
            // Scroll to bottom
            this.scrollToBottom();
        },
        
        // Create a new thread
        createThread: async function() {
            try {
                console.log('Creating new thread...');
                const response = await fetch('/api/openai-api/create-thread', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Thread creation error:', errorData);
                    throw new Error(`Failed to create thread: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Thread created:', data.id);
                return data.id;
            } catch (error) {
                console.error('Error creating thread:', error);
                throw error;
            }
        },
        
        // Send a message
        sendMessage: async function() {
            const messageText = this.elements.input.value.trim();
            
            if (!messageText || this.state.isProcessing) {
                return;
            }
            
            try {
                // Set processing state
                this.state.isProcessing = true;
                this.elements.sendBtn.disabled = true;
                
                // Clear input
                this.elements.input.value = '';
                this.elements.input.style.height = 'auto';
                
                // Add message to UI
                this.addMessageToUI(messageText, true);
                
                // Save user message to state
                this.state.messages.push({
                    content: messageText,
                    isUser: true,
                    timestamp: new Date().toISOString()
                });
                this.saveState();
                
                // Add message to thread
                console.log('Adding message to thread:', this.state.threadId);
                await this.addMessageToThread(messageText);
                
                // Process assistant response
                await this.processResponse();
            } catch (error) {
                console.error('Error sending message:', error);
                this.addMessageToUI("Sorry, er ging iets mis bij het verwerken van je bericht. Probeer het later nog eens.", false);
                
                // Add error message to state
                this.state.messages.push({
                    content: "Sorry, er ging iets mis bij het verwerken van je bericht. Probeer het later nog eens.",
                    isUser: false,
                    timestamp: new Date().toISOString()
                });
                this.saveState();
            } finally {
                // Reset processing state
                this.state.isProcessing = false;
                this.elements.sendBtn.disabled = false;
                this.elements.input.focus();
            }
        },
        
        // Add message to thread via API
        addMessageToThread: async function(content) {
            try {
                const response = await fetch('/api/openai-api/add-message', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        threadId: this.state.threadId,
                        content: content
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Add message error:', errorData);
                    throw new Error(`Failed to add message: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Message added:', data.id);
                return data;
            } catch (error) {
                console.error('Error adding message to thread:', error);
                throw error;
            }
        },
        
        // Process the assistant's response
        processResponse: async function() {
            try {
                // Show typing indicator
                this.showTypingIndicator();
                
                // Create a run
                console.log('Creating run for thread:', this.state.threadId);
                const runResponse = await fetch('/api/openai-api/create-run', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        threadId: this.state.threadId
                    })
                });
                
                if (!runResponse.ok) {
                    const errorData = await runResponse.json();
                    console.error('Create run error:', errorData);
                    throw new Error(`Failed to create run: ${runResponse.status} ${runResponse.statusText}`);
                }
                
                const runData = await runResponse.json();
                console.log('Run created:', runData.id);
                const runId = runData.id;
                
                // Poll for run completion
                let status = 'queued';
                let attempts = 0;
                const maxAttempts = 30;
                
                while (status !== 'completed' && status !== 'failed' && status !== 'expired' && status !== 'cancelled' && attempts < maxAttempts) {
                    attempts++;
                    
                    // Wait for 1 second before checking status
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Check run status
                    console.log(`Checking run status (attempt ${attempts})...`);
                    const statusResponse = await fetch(`/api/openai-api/check-run-status?threadId=${this.state.threadId}&runId=${runId}`);
                    
                    if (!statusResponse.ok) {
                        const errorData = await statusResponse.json();
                        console.error('Check run status error:', errorData);
                        throw new Error(`Failed to check run status: ${statusResponse.status} ${statusResponse.statusText}`);
                    }
                    
                    // Parse the JSON response to get the status
                    const statusData = await statusResponse.json();
                    status = statusData.status;
                    console.log('Run status:', status);
                    
                    if (status === 'completed') {
                        // Get messages
                        console.log('Run completed, fetching messages...');
                        const messagesResponse = await fetch(`/api/openai-api/get-messages?threadId=${this.state.threadId}`);
                        
                        if (!messagesResponse.ok) {
                            const errorData = await messagesResponse.json();
                            console.error('Get messages error:', errorData);
                            throw new Error(`Failed to get messages: ${messagesResponse.status} ${messagesResponse.statusText}`);
                        }
                        
                        const messagesData = await messagesResponse.json();
                        console.log('Messages received:', messagesData);
                        
                        // Find the assistant's response (most recent assistant message)
                        const assistantMessage = messagesData.data.find(msg => msg.role === 'assistant');
                        
                        if (assistantMessage && assistantMessage.content && assistantMessage.content.length > 0) {
                            // Remove typing indicator
                            this.removeTypingIndicator();
                            
                            // Add assistant's response to UI
                            const responseContent = assistantMessage.content[0].text.value;
                            console.log('Assistant response:', responseContent);
                            this.addMessageToUI(responseContent, false);
                            
                            // Save assistant message to state
                            this.state.messages.push({
                                content: responseContent,
                                isUser: false,
                                timestamp: new Date().toISOString()
                            });
                            this.saveState();
                        } else {
                            console.error('No valid assistant message found');
                            throw new Error('No valid assistant message found');
                        }
                    } else if (status === 'failed' || status === 'expired' || status === 'cancelled') {
                        throw new Error(`Run ${status}`);
                    }
                }
                
                if (attempts >= maxAttempts && status !== 'completed') {
                    throw new Error('Timed out waiting for response');
                }
            } catch (error) {
                console.error('Error processing response:', error);
                this.removeTypingIndicator();
                this.addMessageToUI("Sorry, ik kan op dit moment niet reageren. Probeer het later nog eens.", false);
                
                // Add error message to state
                this.state.messages.push({
                    content: "Sorry, ik kan op dit moment niet reageren. Probeer het later nog eens.",
                    isUser: false,
                    timestamp: new Date().toISOString()
                });
                this.saveState();
            }
        },
        
        // Add message to UI
        addMessageToUI: function(content, isUser, animate = true) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isUser ? 'user' : 'assistant'}`;
            
            // Format message content (handle links, line breaks)
            const formattedContent = this.formatMessageContent(content);
            
            messageDiv.innerHTML = formattedContent;
            
            this.elements.messagesContainer.appendChild(messageDiv);
            this.scrollToBottom();
        },
        
        // Format message content
        formatMessageContent: function(content) {
            // Convert URLs to links
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const withLinks = content.replace(urlRegex, '<a href="$1" target="_blank" class="underline gold-text">$1</a>');
            
            // Convert line breaks to <br>
            return withLinks.replace(/\n/g, '<br>');
        },
        
        // Show typing indicator
        showTypingIndicator: function() {
            const typingDiv = document.createElement('div');
            typingDiv.id = 'typing-indicator';
            typingDiv.className = 'typing-indicator';
            typingDiv.innerHTML = `
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            `;
            
            this.elements.messagesContainer.appendChild(typingDiv);
            this.scrollToBottom();
        },
        
        // Remove typing indicator
        removeTypingIndicator: function() {
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        },
        
        // Scroll to the bottom of the messages container
        scrollToBottom: function() {
            this.elements.messagesContainer.scrollTop = this.elements.messagesContainer.scrollHeight;
        }
    };
    
    // Initialize the chat widget
    chatWidget.init();
});
